package tpl

import (
	"buildx/global"
	"buildx/libs"
	"fmt"
	"github.com/spf13/cobra"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"reflect"
	"regexp"
	"sort"
	"strings"
	"text/template"
)

var (
	re = regexp.MustCompile(`\{(\w+)}`)
	// 正则表达式
	routeRegex = regexp.MustCompile(`@Router\s+(\S+)\s+\[(\w+)\]`)
	//descRegex       = regexp.MustCompile(`@Desc\s+(.+)`)
	groupRegex = regexp.MustCompile(`@Group\s+(.+)`)
	//rolesRegex      = regexp.MustCompile(`@Roles\s+([^\s]+)`)
	//permissionRegex = regexp.MustCompile(`@Permission\s+([^\s]+)`)
)

type Route struct {
	HTTPMethod  string
	Path        string
	Func        string
	PackagePath string
	PackageName string
}

type TemplateRoute struct {
	Group   string
	Method  string
	Path    string
	Handler string
}

type GroupedRouters struct {
	GroupName string
	Routers   []TemplateRoute
}

type TemplateData struct {
	Imports     []string
	Groups      []string
	Grouped     []GroupedRouters
	ProjectName string
}

const routeTemplate = `// Code generated by build tool. DO NOT EDIT.

package routers

import (
	"{{ .ProjectName }}/internal/bootstrap"
	"github.com/gin-gonic/gin"
	"gorm.io/gorm"
)

type routeGroup struct {
{{- range .Groups }}
	{{ . }} *gin.RouterGroup
{{- end }}
}

func (r *routeGroup) register(db *gorm.DB) {
	// 初始化仓库和服务
	ctx := bootstrap.NewAppContext(db)
{{- range $gIndex, $group := .Grouped }}
{{- range $group.Routers }}
	r.{{ .Group }}.{{ .Method }}("{{ .Path }}", {{ .Handler }})
{{- end }}
{{- if lt $gIndex (sub1 (len $.Grouped)) }}
{{ end }}
{{- end }}
}`

func writeRouters(routers map[string][]Route) error {
	funcMap := template.FuncMap{
		"len":  func(v interface{}) int { return reflect.ValueOf(v).Len() },
		"sub1": func(i int) int { return i - 1 },
	}

	tmpl, err := template.New("routers").Funcs(funcMap).Parse(routeTemplate)
	if err != nil {
		return fmt.Errorf("解析模板失败: %w", err)
	}

	// 收集 分组、组内路由
	var groups []string
	groupMap := make(map[string][]TemplateRoute)

	for groupName, routeList := range routers {
		groups = append(groups, groupName)
		for _, route := range routeList {
			groupMap[groupName] = append(groupMap[groupName], TemplateRoute{
				Group:   groupName,
				Method:  strings.ToUpper(route.HTTPMethod),
				Path:    route.Path,
				Handler: fmt.Sprintf("ctx.%s.%s", route.PackageName, route.Func),
			})
		}
	}
	sort.Strings(groups)

	var grouped []GroupedRouters
	for _, g := range groups {
		grouped = append(grouped, GroupedRouters{
			GroupName: g,
			Routers:   groupMap[g],
		})
	}

	data := TemplateData{
		Groups:      groups,
		Grouped:     grouped,
		ProjectName: strings.TrimSpace(getModuleName()),
	}

	routerPath := "internal/bootstrap/routers/router.go"
	// 判断 routers 文件夹是否存在，不存在则创建
	if !libs.IsDirExist(dir(routerPath)) {
		if err = os.MkdirAll(dir(routerPath), os.ModePerm); err != nil {
			return fmt.Errorf("创建 routers 文件夹失败: %w", err)
		}
	}

	// 输出
	f, err := os.Create(routerPath)
	if err != nil {
		return fmt.Errorf("创建文件失败: %w", err)
	}
	defer f.Close()

	if err := tmpl.Execute(f, data); err != nil {
		return fmt.Errorf("执行模板失败: %w", err)
	}

	fmt.Println("✅ 路由文件生成成功:", routerPath)
	return nil
}

func regRouter() {
	routes := make(map[string][]Route)
	fset := token.NewFileSet()

	// 递归遍历 controller 目录下所有 go 文件
	_ = filepath.WalkDir("internal/interfaces", func(path string, d os.DirEntry, err error) error {
		if err != nil {
			return err
		}
		// 只处理 .go 文件
		if !d.IsDir() && strings.HasSuffix(d.Name(), ".go") {
			// 获取包名（根据目录路径）
			dir := filepath.Dir(path)
			pkgPath := fmt.Sprintf("%s/%s", getModuleName(), strings.Replace(dir, "\\", "/", -1))
			pkgName, _ := parseFile(path, "Handler")

			// 解析文件
			node, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
			if err != nil {
				return err
			}

			for _, decl := range node.Decls {
				if fn, ok := decl.(*ast.FuncDecl); ok && fn.Doc != nil {
					route := Route{
						Func:        fn.Name.Name,
						PackagePath: pkgPath,
						PackageName: pkgName,
					}
					group := "Public"
					for _, comment := range fn.Doc.List {
						// 匹配 @Route
						if routeMatches := routeRegex.FindStringSubmatch(comment.Text); routeMatches != nil {
							route.Path = re.ReplaceAllString(strings.TrimSpace(routeMatches[1]), `:$1`)
							route.HTTPMethod = strings.ToUpper(strings.TrimSpace(routeMatches[2]))
						}
						// 匹配 @Group
						if groupMatches := groupRegex.FindStringSubmatch(comment.Text); groupMatches != nil {
							group = strings.TrimSpace(groupMatches[1])
						}
					}
					fmt.Printf("发现路由: %s %s %s -> %s.%s\n", group, route.HTTPMethod, route.Path, pkgName, fn.Name.Name)
					routes[group] = append(routes[group], route)
				}
			}
		}
		return nil
	})

	// 写入路由文件
	if err := writeRouters(routes); err != nil {
		fmt.Println("❌ 出错啦：", err)
	}
}

var routerCmd = &cobra.Command{
	Use:   "router",
	Short: "自动注册 Gin 框架路由",
	Run: func(cmd *cobra.Command, args []string) {
		regRouter()
	},
}

func init() {
	routerCmd.SetUsageTemplate(fmt.Sprintf("Usage:\n  %s gin router\t自动注册路由\n\nGlobal Flags:\n{{.Flags.FlagUsages}}", global.ExeFileName))
}
